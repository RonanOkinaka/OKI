#ifndef OKI_HANDLE_H
#define OKI_HANDLE_H

#include <cstdint>

namespace oki
{
    /*
     * The handle "type" used throughout the library as a key.
     * It is lightweight (one integer right now) but purposely opaque
     * and should not be assumed to be an integral or consistent type.
     */
    using Handle = std::uint64_t;

    namespace intl_
    {
        /*
         * This is the global value that oki will use for invalid handles.
         * Any handle value that compares equal to this cannot be valid.
         */
        template <typename HandleType = oki::Handle>
        constexpr HandleType get_invalid_handle_constant() noexcept
        {
            return 0;
        }

        /*
         * Return the first handle. Handles are generated by repeatedly calling
         * oki::advance() on the returned value.
         */
        template <typename HandleType = oki::Handle>
        constexpr HandleType get_first_valid_handle() noexcept
        {
            return 1;
        }

        /*
         * This is different from the handle generators' verify_handle().
         * Returning false does NOT mean that <handle> is valid, only that
         * it isn't a "bad handle" (the invalid handle constant). There are
         * other conditions that must hold for the handle to be valid.
         */
        template <typename HandleType = oki::Handle>
        constexpr bool is_bad_handle(const HandleType handle) noexcept
        {
            return oki::intl_::get_invalid_handle_constant<HandleType>() == handle;
        }

        /*
         * Keeping in line with the opaque handle type, we obscure how
         * the next Handle is generated.
         * Returns the old (pre-advance) value of the handle.
         */
        template <typename HandleType = oki::Handle>
        constexpr HandleType advance(HandleType& handle) noexcept
        {
            return handle++;
        }
    }
}

#endif // OKI_HANDLE_H
